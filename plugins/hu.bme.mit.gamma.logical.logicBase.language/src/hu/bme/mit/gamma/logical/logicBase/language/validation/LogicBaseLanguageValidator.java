/*
 * generated by Xtext 2.17.0
 */
package hu.bme.mit.gamma.logical.logicBase.language.validation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

import org.eclipse.xtext.validation.Check;

import hu.bme.mit.gamma.logical.logicBase.model.LogicalDiagram;
import hu.bme.mit.gamma.logical.logicBase.model.ModelPackage;
import hu.bme.mit.gamma.logical.logicBase.model.NamedObject;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class LogicBaseLanguageValidator extends AbstractLogicBaseLanguageValidator {
	
	@Check
	public void sameInterfaceNameCheck(LogicalDiagram diagram) {
		nameCollisionGeneralCheck(
				diagram.getInterfaces(),
				"The name is used by multiple interfaces.");
	}
	
	/**
	 * Checks and reports the name collisions of {@link NamedObject}s in namedObjects as errors.
	 * @exception NullPointerException Iff any of the arguments is null.
	 */
	protected <T extends NamedObject> void nameCollisionGeneralCheck(List<T> namedObjects, String nameCollisionErrorMessage) {
		List<Internal.Pair<T, T>> nameCollisions = nameCollisionsIn(namedObjects);
		reportNameCollisionErrors(nameCollisionErrorMessage, nameCollisions);
	}
	
	/**
	 * @exception NullPointerException Iff any of the arguments is null or nameCollisions contains null.
	 */
	private <T extends NamedObject> void reportNameCollisionErrors(String errorMessage, List<Internal.Pair<T, T>> nameCollisions) {
		nameCollisions.forEach(collision->{
			nameCollisionError(
					errorMessage,
					collision.getA());
		});
	}
	
	/**
	 * @exception NullPointerException Iff any of the arguments is null.
	 */
	private <T extends NamedObject> void nameCollisionError(String errorMessage, T namedObjectWithCollidingName) {
		if(errorMessage == null) throw new NullPointerException();
		if(namedObjectWithCollidingName == null) throw new NullPointerException();
		
		error(
				errorMessage,
				namedObjectWithCollidingName,
				ModelPackage.Literals.NAMED_OBJECT__NAME);
		
	}
	
	/**
	 * Every name collision is contained twice.
	 * @exception NullPointerException Iff objs is null or obj contains null.
	 */
	private <T extends NamedObject> List<Internal.Pair<T, T>> nameCollisionsIn(List<T> objs) {
		return Internal.Pairs.of(objs).stream()
			.filter(pair -> capturesNameCollision(pair))
			.collect(Collectors.toList());
	}
	
	/**
	 * @exception NullPointerException Iff pair is null or any of its elements is null.
	 */
	private <T extends NamedObject> boolean capturesNameCollision(Internal.Pair<T, T> pair) {
		return (pair.getA() != pair.getB()) && 
				(nameEquals(pair.getA(), pair.getB()));
	}
	
	/**
	 * @exception NullPointerException Iff A or B is null.
	 */
	private static boolean nameEquals(NamedObject A, NamedObject B) {
		if(A.getName() == null) {
			return false;
		}
		else if(B.getName() == null) {
			return false;
		}
		else {
			return A.getName().equals(B.getName());
		}
	}
	
	private static class Internal {
		private static final class Pairs{
			/**
			 * @exception NullPointerException Iff elements is null.
			 */
			public static <T> Collection<Pair<T, T>> of(Iterable<T> elements) {
				List<Pair<T, T>> pairs = new ArrayList<>();
				
				for(T element1 : elements) {
					for(T element2 : elements) {
						pairs.add(new Pair<T, T>(element1, element2));
					}
				}
				
				return pairs;
			}
		}
		
		public static final class Pair<T, U> {
			private final T A;
			private final U B;
			
			public Pair(T a, U b) {
				A = a;
				B = b;
			}
			
			public T getA() {
				return A;
			}
			public U getB() {
				return B;
			}

			@Override
			public int hashCode() {
				final int prime = 31;
				int result = 1;
				result = prime * result + ((A == null) ? 0 : A.hashCode());
				result = prime * result + ((B == null) ? 0 : B.hashCode());
				return result;
			}

			@Override
			@SuppressWarnings("all")
			public boolean equals(Object obj) {
				if (this == obj)
					return true;
				if (obj == null)
					return false;
				if (getClass() != obj.getClass())
					return false;
				Pair other = (Pair) obj;
				if (A == null) {
					if (other.A != null)
						return false;
				} else if (!A.equals(other.A))
					return false;
				if (B == null) {
					if (other.B != null)
						return false;
				} else if (!B.equals(other.B))
					return false;
				return true;
			}

			@Override
			public String toString() {
				return "(" + A.toString() +", "+B.toString()+")";
			}
		}
	}
	
//	public static final INVALID_NAME = 'invalidName'
//
//	@Check
//	public void checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
//			warning("Name should start with a capital",
//					LogicBaseLanguagePackage.Literals.GREETING__NAME,
//					INVALID_NAME);
//		}
//	}
	
}
